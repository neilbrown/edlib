#!/bin/bash

# This script handles management of testing.
# It supports the creation, verification, and updating
# of tests.
#
# Tests are run in the context of an edlib git tree
# with a given hash - currently the same hash for all tests.
# Each test provides a list of keystrokes and mouse actions
# together with occasions checksums of the current display.
# We run a test and record the output at the same time, then
# confirm that the recording matching the input test.

# Usage:
# ./tests new name
#     Record a new test and store it with given name.  Then re-run and confirm.
# ./tests run [name|failed]
#     If a name is given, just that test is run.  If no name is given, all tests
#     are run.  If any test fails, that failure is recorded.
#     If the special name 'failed' is given, then only failed tests are run.
# ./tests refresh
#     Run all tests and replace the test with the new log - expecting it to be different.

# ensure timestamps don't change
export EDLIB_FAKE_TIME=1581382278

export TEST_DIR=/tmp/edlib-tests
export TEST_COMMIT=5875a3514f4e753fa183a2e19000e803384fae77

runtest()
{
	case $# in
	1 ) EDLIB_RECORD=$1 \
		screen -m sh -c 'stty rows 30 cols 80; ./edlib $TEST_DIR'
	;;
	2 ) EDLIB_RECORD=$1 EDLIB_REPLAY=$2 \
		screen -D -m sh -c 'stty rows 30 cols 80; ./edlib $TEST_DIR'
	;;
	esac
}

cmd=$0

setup_test_dir() {
    if [ -d $TEST_DIR -a -d $TEST_DIR/.git ]; then
	(cd $TEST_DIR ; git reset > /dev/null --hard $TEST_COMMIT ; git clean -fxd)
    else
	rm -rf $TEST_DIR
	git clone . $TEST_DIR
	(cd $TEST_DIR ; git reset --hard $TEST_COMMIT)
    fi
}

new_test() {
    if [ $# -ne 1 ]; then
	echo >&2 "$0: please provide name for new test"
	exit 1
    fi
    t=$1
    tt=tests.d/$t
    if [ -e "$tt" ]; then
	echo >&2 "$0: $tt already exists, please choose another name"
	exit 1
    fi
    if ! touch "$tt"; then
	echo >&2 "$0: Cannot create $tt - strange"
	exit 1
    fi
    runtest tests.d/.tmp
    runtest $tt tests.d/.tmp
    diff -u tests.d/.tmp $tt
    rm tests.d/.tmp
    exit 0
}

run_one_test() {
    if [ ! -f "tests.d/$1" ]; then
	echo "$cmd: test $1 doesn't exist"
	exit_code=2
	return
    fi
    echo -n "run $1 ..."
    runtest tests.d/.out tests.d/$1
    if diff -u "tests.d/$1" tests.d/.out;
    then echo "succeeded."
    else echo "FAILED."
         exit_code=1
    fi
    rm -f tests.d/.out
}

run_tests() {
    if [ $# -gt 1 ]; then
	echo >&2 "$0: please provide at most one test to run"
	exit 1
    fi
    exit_code=0
    if [ $# -eq 0 ]; then
	for f in tests.d/[A-Za-z0-9]*; do
	    b=${f#tests.d/}
	    run_one_test "$b"
	done
    else
	run_one_test "$1"
    fi
    exit $exit_code
}

refresh_tests() {
    if [ $# -ne 0 ]; then
	echo >&2 "$0: please don't give extra args to refresh"
	exit 1
    fi
    for f in tests.d/[A-Za-z0-9]*; do
	b=${f#tests.d/}
	runtest tests.d/.out tests.d/$b
	mv tests.d/.out $f
    done
}


cmd=$1
shift
case $cmd in
	new) setup_test_dir; new_test $*;;
	run) setup_test_dir; run_tests $*;;
	refresh) setup_test_dir; refresh_tests $*;;
	* )
		echo >&2 "Usage: $0 new test-name"
		echo >&2 "       $0 run [test-name|failed]"
		echo >&2 "       $0 refresh"
		exit 1;
esac
exit 0

